{"version":3,"sources":["modules/RTCModule.js","config.js","modules/FirebaseModule.js","VideoChat.js","VideoChatContainer.js","App.js","serviceWorker.js","index.js"],"names":["createOffer","connection","localStream","userToCall","doOffer","database","username","a","addStream","offer","setLocalDescription","console","error","initiateLocalStream","navigator","mediaDevices","getUserMedia","video","audio","stream","initiateConnection","conn","RTCPeerConnection","iceServers","urls","listenToConnectionEvents","remoteUsername","remoteVideoRef","doCandidate","onicecandidate","event","candidate","ontrack","e","srcObject","streams","sendAnswer","notif","doAnswer","JSON","parse","setRemoteDescription","createAnswer","answer","from","startCall","yourConn","addCandidate","addIceCandidate","RTCIceCandidate","config","apiKey","authDomain","databaseURL","projectId","storageBucket","messagingSenderId","appId","doLogin","handleUpdate","ref","remove","on","snapshot","exists","val","to","set","type","stringify","update","VideoChat","props","onLoginClicked","onLogin","state","setState","isLoggedIn","onStartCallClicked","renderVideos","className","classnames","active","setLocalVideoRef","autoPlay","playsInline","connectedUser","setRemoteVideoRef","renderForms","key","value","onChange","target","onClick","id","this","React","Component","VideoChatContainer","componentDidMount","firebase","initializeApp","localVideoRef","localConnection","createRef","nextProps","nextState","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.dd576088.chunk.js","sourcesContent":["\nexport const createOffer = async (connection, localStream, userToCall, doOffer, database, username) => {\n  try {\n    connection.addStream(localStream)\n\n    const offer = await connection.createOffer()\n    await connection.setLocalDescription(offer)\n\n    doOffer(userToCall, offer, database, username)\n  } catch (exception) {\n    console.error(exception)\n  }\n}\n\nexport const initiateLocalStream = async () => {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      video: true,\n      audio: true\n    })\n    return stream\n  } catch (exception) {\n    console.error(exception)\n  }\n}\nexport const initiateConnection = async () => {\n  try {\n    // using Google public stun server\n    var configuration = {\n      iceServers: [{ urls: 'stun:stun2.1.google.com:19302' }]\n    }\n\n    const conn = new RTCPeerConnection(configuration)\n\n    return conn\n  } catch (exception) {\n    console.error(exception)\n  }\n}\n\nexport const listenToConnectionEvents = (conn, username, remoteUsername, database, remoteVideoRef, doCandidate) => {\n  conn.onicecandidate = function (event) {\n    if (event.candidate) {\n      doCandidate(remoteUsername, event.candidate, database, username)\n    }\n  }\n\n  // when a remote user adds stream to the peer connection, we display it\n  conn.ontrack = function (e) {\n    if (remoteVideoRef.srcObject !== e.streams[0]) {\n      remoteVideoRef.srcObject = e.streams[0]\n    }\n  }\n}\n\nexport const sendAnswer = async (conn, localStream, notif, doAnswer, database, username) => {\n  try {\n    conn.addStream(localStream)\n\n    const offer = JSON.parse(notif.offer)\n    conn.setRemoteDescription(offer)\n\n    // create an answer to an offer\n    const answer = await conn.createAnswer()\n    conn.setLocalDescription(answer)\n\n    doAnswer(notif.from, answer, database, username)\n  } catch (exception) {\n    console.error(exception)\n  }\n}\n\nexport const startCall = (yourConn, notif) => {\n  const answer = JSON.parse(notif.answer)\n  yourConn.setRemoteDescription(answer)\n}\n\nexport const addCandidate = (yourConn, notif) => {\n  // apply the new received candidate to the connection\n  const candidate = JSON.parse(notif.candidate)\n  yourConn.addIceCandidate(new RTCIceCandidate(candidate))\n}\n","\nconst config = {\n  apiKey: \"AIzaSyC1O3pc7AQ1SOVUU0u6_7qfeIuVrUGCEVw\",\n  authDomain: \"serverless-video-chat.firebaseapp.com\",\n  databaseURL: \"https://serverless-video-chat.firebaseio.com\",\n  projectId: \"serverless-video-chat\",\n  storageBucket: \"serverless-video-chat.appspot.com\",\n  messagingSenderId: \"728740478864\",\n  appId: \"1:728740478864:web:fc584331943322ea6bfd15\",\n}\n\nexport default config","\nexport const doLogin = async (username, database, handleUpdate) => {\n  await database.ref('/notifs/' + username).remove()\n  database.ref('/notifs/' + username).on('value', snapshot => {\n    snapshot.exists() && handleUpdate(snapshot.val(), username)\n  })\n}\n\nexport const doOffer = async (to, offer, database, username) => {\n  await database.ref('/notifs/' + to).set({\n    type: 'offer',\n    from: username,\n    offer: JSON.stringify(offer)\n  })\n}\n\nexport const doAnswer = async (to, answer, database, username) => {\n  await database.ref('/notifs/' + to).update({\n    type: 'answer',\n    from: username,\n    answer: JSON.stringify(answer)\n  })\n}\n\nexport const doLeaveNotif = async (to, database, username) => {\n  await database.ref('/notifs/' + to).update({\n    type: 'leave',\n    from: username\n  })\n}\n\nexport const doCandidate = async (to, candidate, database, username) => {\n  // send the new candiate to the peer\n  await database.ref('/notifs/' + to).update({\n    type: 'candidate',\n    from: username,\n    candidate: JSON.stringify(candidate)\n  })\n}\n","import React from 'react'\nimport './App.css'\nimport 'firebase/database'\nimport classnames from 'classnames'\n\nexport default class VideoChat extends React.Component {\n  constructor (props) {\n    super(props)\n    this.state = {\n      isLoggedIn: false,\n      userToCall: null,\n      username: null\n    }\n  }\n\n  onLoginClicked = async () => {\n    await this.props.onLogin(this.state.username)\n    this.setState({\n      isLoggedIn: true\n    })\n  }\n\n  onStartCallClicked = () => {\n    this.props.startCall(this.state.username, this.state.userToCall)\n  }\n\n  renderVideos = () => {\n    return <div className={classnames('videos', { active: this.state.isLoggedIn })}>\n      <div>\n        <label>{this.state.username}</label>\n\n        <video ref={this.props.setLocalVideoRef} autoPlay playsInline></video>\n      </div>\n      <div>\n        <label>{this.props.connectedUser}</label>\n        <video ref={this.props.setRemoteVideoRef} autoPlay playsInline></video>\n      </div>\n\n    </div>\n  }\n\n  renderForms = () => {\n    return this.state.isLoggedIn\n      ? <div key='a' className='form'>\n        <label>Call to</label>\n        <input value={this.state.userToCall} type=\"text\" onChange={e => this.setState({ userToCall: e.target.value })} />\n        <button onClick={this.onStartCallClicked} id=\"call-btn\" className=\"btn btn-primary\">Call</button>\n\n      </div>\n      : <div key='b' className='form'>\n        <label>Type a name</label>\n        <input value={this.state.username} type=\"text\" onChange={e => this.setState({ username: e.target.value })} />\n\n        <button onClick={this.onLoginClicked} id=\"login-btn\" className=\"btn btn-primary\">Login</button>\n\n      </div>\n  }\n\n  render () {\n    return <section id=\"container\">\n      {this.props.connectedUser ? null : this.renderForms()}\n\n      {this.renderVideos()}\n\n    </section>\n  }\n}\n","import React from 'react'\nimport './App.css'\nimport { createOffer, initiateConnection, startCall, sendAnswer, addCandidate, initiateLocalStream, listenToConnectionEvents } from './modules/RTCModule'\nimport firebase from 'firebase/app'\nimport 'firebase/database'\nimport config from './config'\nimport { doOffer, doAnswer, doLogin, doCandidate } from './modules/FirebaseModule'\nimport 'webrtc-adapter'\nimport VideoChat from './VideoChat'\n\nclass VideoChatContainer extends React.Component {\n  constructor (props) {\n    super(props)\n    this.state = {\n      database: null,\n      connectedUser: null,\n      localStream: null,\n      localConnection: null\n    }\n    this.localVideoRef = React.createRef()\n    this.remoteVideoRef = React.createRef()\n  }\n\n    componentDidMount = async () => {\n      firebase.initializeApp(config)\n\n      // getting local video stream\n      const localStream = await initiateLocalStream()\n      this.localVideoRef.srcObject = localStream\n\n      const localConnection = await initiateConnection()\n\n      this.setState({\n        database: firebase.database(),\n        localStream,\n        localConnection\n      })\n    }\n\n    shouldComponentUpdate (nextProps, nextState) {\n      if (this.state.database !== nextState.database) {\n        return false\n      }\n      if (this.state.localStream !== nextState.localStream) {\n        return false\n      }\n      if (this.state.localConnection !== nextState.localConnection) {\n        return false\n      }\n\n      return true\n    }\n\n    startCall = async (username, userToCall) => {\n      const { localConnection, database, localStream } = this.state\n      listenToConnectionEvents(localConnection, username, userToCall, database, this.remoteVideoRef, doCandidate)\n      // create an offer\n      createOffer(localConnection, localStream, userToCall, doOffer, database, username)\n    }\n\n    onLogin = async (username) => {\n      return await doLogin(username, this.state.database, this.handleUpdate)\n    }\n\n    setLocalVideoRef = ref => {\n      this.localVideoRef = ref\n    }\n\n    setRemoteVideoRef = ref => {\n      this.remoteVideoRef = ref\n    }\n\n    handleUpdate = (notif, username) => {\n      const { localConnection, database, localStream } = this.state\n\n      if (notif) {\n        switch (notif.type) {\n          case 'offer':\n            this.setState({\n              connectedUser: notif.from\n            })\n\n            listenToConnectionEvents(localConnection, username, notif.from, database, this.remoteVideoRef, doCandidate)\n\n            sendAnswer(localConnection, localStream, notif, doAnswer, database, username)\n            break\n          case 'answer':\n\n            this.setState({\n              connectedUser: notif.from\n            })\n            startCall(localConnection, notif)\n            break\n          case 'candidate':\n            addCandidate(localConnection, notif)\n            break\n          default:\n            break\n        }\n      }\n    }\n\n    render () {\n      return <VideoChat\n        startCall={this.startCall}\n        onLogin={this.onLogin}\n        setLocalVideoRef={this.setLocalVideoRef}\n        setRemoteVideoRef={this.setRemoteVideoRef}\n        connectedUser={this.state.connectedUser}\n      />\n    }\n}\n\nexport default VideoChatContainer\n","import React from 'react'\nimport './App.css'\nimport VideoChatContainer from './VideoChatContainer'\n\nfunction App () {\n  return (\n    <div className='app'>\n      <h1>React Video Chat App</h1>\n      <h2>WebRTC + Firebase</h2>\n      <VideoChatContainer/>\n    </div>\n  )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}